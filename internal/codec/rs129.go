package codec

// RS129 implements Reed-Solomon (12,9) error correction code
// This matches the C++ CRS129 class functionality for YSF FIC protection
//
// Code parameters:
// - (n,k) = (12,9): 12 total symbols, 9 data symbols, 3 parity symbols
// - Works over GF(256) with primitive polynomial x^8 + x^4 + x^3 + x^2 + 1
// - Can correct up to 1 symbol error
// - Used for YSF Frame Information Channel (FIC) protection

// Constants from C++ implementation
const (
	RS129_NPAR = 3 // Number of parity symbols
)

// Generator polynomial coefficients (from C++ POLY array)
var RS129_POLY = [12]uint8{64, 56, 14, 1, 0, 0, 0, 0, 0, 0, 0, 0}

// GF(256) exponential table (antilog table) - duplicated for easier indexing
var RS129_EXP_TABLE = [512]uint8{
	0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1D, 0x3A, 0x74, 0xE8, 0xCD, 0x87, 0x13, 0x26,
	0x4C, 0x98, 0x2D, 0x5A, 0xB4, 0x75, 0xEA, 0xC9, 0x8F, 0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0,
	0x9D, 0x27, 0x4E, 0x9C, 0x25, 0x4A, 0x94, 0x35, 0x6A, 0xD4, 0xB5, 0x77, 0xEE, 0xC1, 0x9F, 0x23,
	0x46, 0x8C, 0x05, 0x0A, 0x14, 0x28, 0x50, 0xA0, 0x5D, 0xBA, 0x69, 0xD2, 0xB9, 0x6F, 0xDE, 0xA1,
	0x5F, 0xBE, 0x61, 0xC2, 0x99, 0x2F, 0x5E, 0xBC, 0x65, 0xCA, 0x89, 0x0F, 0x1E, 0x3C, 0x78, 0xF0,
	0xFD, 0xE7, 0xD3, 0xBB, 0x6B, 0xD6, 0xB1, 0x7F, 0xFE, 0xE1, 0xDF, 0xA3, 0x5B, 0xB6, 0x71, 0xE2,
	0xD9, 0xAF, 0x43, 0x86, 0x11, 0x22, 0x44, 0x88, 0x0D, 0x1A, 0x34, 0x68, 0xD0, 0xBD, 0x67, 0xCE,
	0x81, 0x1F, 0x3E, 0x7C, 0xF8, 0xED, 0xC7, 0x93, 0x3B, 0x76, 0xEC, 0xC5, 0x97, 0x33, 0x66, 0xCC,
	0x85, 0x17, 0x2E, 0x5C, 0xB8, 0x6D, 0xDA, 0xA9, 0x4F, 0x9E, 0x21, 0x42, 0x84, 0x15, 0x2A, 0x54,
	0xA8, 0x4D, 0x9A, 0x29, 0x52, 0xA4, 0x55, 0xAA, 0x49, 0x92, 0x39, 0x72, 0xE4, 0xD5, 0xB7, 0x73,
	0xE6, 0xD1, 0xBF, 0x63, 0xC6, 0x91, 0x3F, 0x7E, 0xFC, 0xE5, 0xD7, 0xB3, 0x7B, 0xF6, 0xF1, 0xFF,
	0xE3, 0xDB, 0xAB, 0x4B, 0x96, 0x31, 0x62, 0xC4, 0x95, 0x37, 0x6E, 0xDC, 0xA5, 0x57, 0xAE, 0x41,
	0x82, 0x19, 0x32, 0x64, 0xC8, 0x8D, 0x07, 0x0E, 0x1C, 0x38, 0x70, 0xE0, 0xDD, 0xA7, 0x53, 0xA6,
	0x51, 0xA2, 0x59, 0xB2, 0x79, 0xF2, 0xF9, 0xEF, 0xC3, 0x9B, 0x2B, 0x56, 0xAC, 0x45, 0x8A, 0x09,
	0x12, 0x24, 0x48, 0x90, 0x3D, 0x7A, 0xF4, 0xF5, 0xF7, 0xF3, 0xFB, 0xEB, 0xCB, 0x8B, 0x0B, 0x16,
	0x2C, 0x58, 0xB0, 0x7D, 0xFA, 0xE9, 0xCF, 0x83, 0x1B, 0x36, 0x6C, 0xD8, 0xAD, 0x47, 0x8E, 0x01,
	// Duplicated for easier indexing
	0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1D, 0x3A, 0x74, 0xE8, 0xCD, 0x87, 0x13, 0x26, 0x4C,
	0x98, 0x2D, 0x5A, 0xB4, 0x75, 0xEA, 0xC9, 0x8F, 0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0x9D,
	0x27, 0x4E, 0x9C, 0x25, 0x4A, 0x94, 0x35, 0x6A, 0xD4, 0xB5, 0x77, 0xEE, 0xC1, 0x9F, 0x23, 0x46,
	0x8C, 0x05, 0x0A, 0x14, 0x28, 0x50, 0xA0, 0x5D, 0xBA, 0x69, 0xD2, 0xB9, 0x6F, 0xDE, 0xA1, 0x5F,
	0xBE, 0x61, 0xC2, 0x99, 0x2F, 0x5E, 0xBC, 0x65, 0xCA, 0x89, 0x0F, 0x1E, 0x3C, 0x78, 0xF0, 0xFD,
	0xE7, 0xD3, 0xBB, 0x6B, 0xD6, 0xB1, 0x7F, 0xFE, 0xE1, 0xDF, 0xA3, 0x5B, 0xB6, 0x71, 0xE2, 0xD9,
	0xAF, 0x43, 0x86, 0x11, 0x22, 0x44, 0x88, 0x0D, 0x1A, 0x34, 0x68, 0xD0, 0xBD, 0x67, 0xCE, 0x81,
	0x1F, 0x3E, 0x7C, 0xF8, 0xED, 0xC7, 0x93, 0x3B, 0x76, 0xEC, 0xC5, 0x97, 0x33, 0x66, 0xCC, 0x85,
	0x17, 0x2E, 0x5C, 0xB8, 0x6D, 0xDA, 0xA9, 0x4F, 0x9E, 0x21, 0x42, 0x84, 0x15, 0x2A, 0x54, 0xA8,
	0x4D, 0x9A, 0x29, 0x52, 0xA4, 0x55, 0xAA, 0x49, 0x92, 0x39, 0x72, 0xE4, 0xD5, 0xB7, 0x73, 0xE6,
	0xD1, 0xBF, 0x63, 0xC6, 0x91, 0x3F, 0x7E, 0xFC, 0xE5, 0xD7, 0xB3, 0x7B, 0xF6, 0xF1, 0xFF, 0xE3,
	0xDB, 0xAB, 0x4B, 0x96, 0x31, 0x62, 0xC4, 0x95, 0x37, 0x6E, 0xDC, 0xA5, 0x57, 0xAE, 0x41, 0x82,
	0x19, 0x32, 0x64, 0xC8, 0x8D, 0x07, 0x0E, 0x1C, 0x38, 0x70, 0xE0, 0xDD, 0xA7, 0x53, 0xA6, 0x51,
	0xA2, 0x59, 0xB2, 0x79, 0xF2, 0xF9, 0xEF, 0xC3, 0x9B, 0x2B, 0x56, 0xAC, 0x45, 0x8A, 0x09, 0x12,
	0x24, 0x48, 0x90, 0x3D, 0x7A, 0xF4, 0xF5, 0xF7, 0xF3, 0xFB, 0xEB, 0xCB, 0x8B, 0x0B, 0x16, 0x2C,
	0x58, 0xB0, 0x7D, 0xFA, 0xE9, 0xCF, 0x83, 0x1B, 0x36, 0x6C, 0xD8, 0xAD, 0x47, 0x8E, 0x01, 0x00,
}

// GF(256) logarithm table (from C++ LOG_TABLE)
var RS129_LOG_TABLE = [256]uint8{
	0x00, 0x00, 0x01, 0x19, 0x02, 0x32, 0x1A, 0xC6, 0x03, 0xDF, 0x33, 0xEE, 0x1B, 0x68, 0xC7, 0x4B,
	0x04, 0x64, 0xE0, 0x0E, 0x34, 0x8D, 0xEF, 0x81, 0x1C, 0xC1, 0x69, 0xF8, 0xC8, 0x08, 0x4C, 0x71,
	0x05, 0x8A, 0x65, 0x2F, 0xE1, 0x24, 0x0F, 0x21, 0x35, 0x93, 0x8E, 0xDA, 0xF0, 0x12, 0x82, 0x45,
	0x1D, 0xB5, 0xC2, 0x7D, 0x6A, 0x27, 0xF9, 0xB9, 0xC9, 0x9A, 0x09, 0x78, 0x4D, 0xE4, 0x72, 0xA6,
	0x06, 0xBF, 0x8B, 0x62, 0x66, 0xDD, 0x30, 0xFD, 0xE2, 0x98, 0x25, 0xB3, 0x10, 0x91, 0x22, 0x88,
	0x36, 0xD0, 0x94, 0xCE, 0x8F, 0x96, 0xDB, 0xBD, 0xF1, 0xD2, 0x13, 0x5C, 0x83, 0x38, 0x46, 0x40,
	0x1E, 0x42, 0xB6, 0xA3, 0xC3, 0x48, 0x7E, 0x6E, 0x6B, 0x3A, 0x28, 0x54, 0xFA, 0x85, 0xBA, 0x3D,
	0xCA, 0x5E, 0x9B, 0x9F, 0x0A, 0x15, 0x79, 0x2B, 0x4E, 0xD4, 0xE5, 0xAC, 0x73, 0xF3, 0xA7, 0x57,
	0x07, 0x70, 0xC0, 0xF7, 0x8C, 0x80, 0x63, 0x0D, 0x67, 0x4A, 0xDE, 0xED, 0x31, 0xC5, 0xFE, 0x18,
	0xE3, 0xA5, 0x99, 0x77, 0x26, 0xB8, 0xB4, 0x7C, 0x11, 0x44, 0x92, 0xD9, 0x23, 0x20, 0x89, 0x2E,
	0x37, 0x3F, 0xD1, 0x5B, 0x95, 0xBC, 0xCF, 0xCD, 0x90, 0x87, 0x97, 0xB2, 0xDC, 0xFC, 0xBE, 0x61,
	0xF2, 0x56, 0xD3, 0xAB, 0x14, 0x2A, 0x5D, 0x9E, 0x84, 0x3C, 0x39, 0x53, 0x47, 0x6D, 0x41, 0xA2,
	0x1F, 0x2D, 0x43, 0xD8, 0xB7, 0x7B, 0xA4, 0x76, 0xC4, 0x17, 0x49, 0xEC, 0x7F, 0x0C, 0x6F, 0xF6,
	0x6C, 0xA1, 0x3B, 0x52, 0x29, 0x9D, 0x55, 0xAA, 0xFB, 0x60, 0x86, 0xB1, 0xBB, 0xCC, 0x3E, 0x5A,
	0xCB, 0x59, 0x5F, 0xB0, 0x9C, 0xA9, 0xA0, 0x51, 0x0B, 0xF5, 0x16, 0xEB, 0x7A, 0x75, 0x2C, 0xD7,
	0x4F, 0xAE, 0xD5, 0xE9, 0xE6, 0xE7, 0xAD, 0xE8, 0x74, 0xD6, 0xF4, 0xEA, 0xA8, 0x50, 0x58, 0xAF,
}

// rs129GMult performs GF(256) multiplication using logarithms
// Equivalent to C++ gmult() function
func rs129GMult(a, b uint8) uint8 {
	if a == 0 || b == 0 {
		return 0
	}

	i := uint32(RS129_LOG_TABLE[a])
	j := uint32(RS129_LOG_TABLE[b])

	return RS129_EXP_TABLE[i+j]
}

// RS129Encode computes Reed-Solomon (12,9) parity bytes
// Input: msg[0:nbytes-1] contains the data bytes to encode
// Output: parity[0:RS129_NPAR-1] contains the computed parity bytes
// Equivalent to C++ CRS129::encode()
func RS129Encode(msg []uint8, nbytes uint32, parity []uint8) {
	if len(parity) < RS129_NPAR+1 {
		return // Need at least 4 bytes for parity
	}

	// Initialize parity array (C++ lines 104-105)
	for i := 0; i < RS129_NPAR+1; i++ {
		parity[i] = 0x00
	}

	// Simulate LFSR with generator polynomial (C++ lines 107-114)
	for i := uint32(0); i < nbytes; i++ {
		if i >= uint32(len(msg)) {
			break
		}

		dbyte := msg[i] ^ parity[RS129_NPAR-1]

		for j := RS129_NPAR - 1; j > 0; j-- {
			parity[j] = parity[j-1] ^ rs129GMult(RS129_POLY[j], dbyte)
		}

		parity[0] = rs129GMult(RS129_POLY[0], dbyte)
	}
}

// RS129Check verifies if a 12-byte Reed-Solomon codeword is valid
// Input: in[0:11] contains the 12-byte codeword (9 data + 3 parity)
// Output: true if codeword is valid, false otherwise
// Equivalent to C++ CRS129::check()
func RS129Check(in []uint8) bool {
	if len(in) < 12 {
		return false // Need at least 12 bytes
	}

	var parity [4]uint8
	RS129Encode(in, 9, parity[:])

	// Check if computed parity matches received parity (C++ line 125)
	return in[9] == parity[2] && in[10] == parity[1] && in[11] == parity[0]
}

// RS129EncodeData is a convenience function for encoding 9-byte data
// Returns the complete 12-byte codeword (9 data + 3 parity)
func RS129EncodeData(data [9]uint8) [12]uint8 {
	var result [12]uint8
	var parity [4]uint8

	// Copy data bytes
	copy(result[:9], data[:])

	// Compute parity
	RS129Encode(data[:], 9, parity[:])

	// Append parity in correct order
	result[9] = parity[2]
	result[10] = parity[1]
	result[11] = parity[0]

	return result
}

// RS129DecodeData attempts to decode a 12-byte codeword
// Returns the 9-byte data portion and a validity flag
func RS129DecodeData(codeword [12]uint8) ([9]uint8, bool) {
	var data [9]uint8
	copy(data[:], codeword[:9])

	valid := RS129Check(codeword[:])
	return data, valid
}

// RS129GetSyndromes computes the syndrome polynomial for error detection
// This is used for more advanced error correction (beyond simple checking)
func RS129GetSyndromes(codeword []uint8) [RS129_NPAR]uint8 {
	var syndromes [RS129_NPAR]uint8

	// Simple syndrome calculation - compute parity and compare
	if len(codeword) >= 12 {
		var parity [4]uint8
		RS129Encode(codeword[:9], 9, parity[:])

		syndromes[0] = codeword[11] ^ parity[0]
		syndromes[1] = codeword[10] ^ parity[1]
		syndromes[2] = codeword[9] ^ parity[2]
	}

	return syndromes
}

// RS129Validate validates the Reed-Solomon implementation
// Used for testing and verification
func RS129Validate() bool {
	// Test encoding and checking for various data patterns
	testData := [][9]uint8{
		{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // All zeros
		{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}, // All ones
		{0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x00}, // Sequential
		{0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA}, // Pattern
		{0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0, 0x11}, // Random
	}

	for _, data := range testData {
		// Encode
		encoded := RS129EncodeData(data)

		// Check
		if !RS129Check(encoded[:]) {
			return false
		}

		// Decode
		decoded, valid := RS129DecodeData(encoded)
		if !valid || decoded != data {
			return false
		}
	}

	return true
}